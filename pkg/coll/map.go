package coll

import (
	"strings"
)

// MapContainsKey checks if a specified key is present within a given map.
//
// This function takes a map with keys of any comparable type `K` and values of
// any type `V`. It checks if the specified `key` exists in the map `m`. If the key
// is found, it returns `true`; otherwise, it returns `false`.
//
// The function is generic and can be used with maps that have keys of any type
// that supports comparison (e.g., int, string). The value type `V` can be any type.
//
// Parameters:
//   - `m`: The map in which to search for the key. The map has keys of type `K`
//     and values of type `V`.
//   - `key`: The key to search for within `m`. It should be of the same type `K` as
//     the keys in `m`.
//
// Returns:
//   - `true` if `key` is found in `m`, `false` otherwise.
//
// Example:
//
//	ages := map[string]int{"Alice": 30, "Bob": 25}
//	isPresent := MapContainsKey(ages, "Alice") // isPresent will be true as "Alice" is a key in the map
//
//	prices := map[int]float64{1: 9.99, 2: 19.99}
//	isPresent := MapContainsKey(prices, 3) // isPresent will be false as 3 is not a key in the map
func MapContainsKey[K comparable, V any](m map[K]V, key K) bool {
	_, ok := m[key]
	return ok
}

// Map returns a new slice where each element is the result of applying a specified
// transformation function to each element in the input slice.
//
// This function iterates over each element in the input slice `list`, applies the
// provided transformation function `f` to it, and stores the result in the new slice
// `result`. The length of the resulting slice is the same as the input slice, and
// each element in `result` corresponds to a transformed element from `list`.
//
// The function is generic, allowing it to work with slices of any type `T` and
// apply a transformation function that converts each element of type `T` to a
// new type `U`.
//
// Parameters:
//   - `list`: The slice of elements to transform. It can contain elements of any type `T`.
//   - `f`: A function that defines the transformation. It takes an element of type `T`
//     as input and returns a transformed value of type `U`.
//
// Returns:
//   - A new slice of type `[]U` where each element is the result of applying `f`
//     to the corresponding element in `list`.
//
// Example:
//
//	numbers := []int{1, 2, 3, 4, 5}
//	squaredNumbers := Map(numbers, func(n int) int { return n * n })
//	// squaredNumbers will be []int{1, 4, 9, 16, 25} as each number is squared
//
//	words := []string{"apple", "banana", "cherry"}
//	wordLengths := Map(words, func(word string) int { return len(word) })
//	// wordLengths will be []int{5, 6, 6} as each word's length is calculated
func Map[T any, U any](list []T, f func(T) U) []U {
	result := make([]U, len(list))
	for i, item := range list {
		result[i] = f(item)
	}
	return result
}

// ToMap converts a slice into a map, using a specified function to generate keys
// for each element in the slice.
//
// This function iterates over each element in the input slice `slice`, applies the
// provided `keyFunc` function to generate a key for each element, and then inserts the
// element into the resulting map `result` using that key. This allows the creation of
// a map from a slice, where each element is accessible via a unique key.
//
// The function is generic, allowing it to operate on slices of any type `T` and
// generate keys of any comparable type `K`. The resulting map will have keys of
// type `K` and values of type `T`.
//
// Parameters:
//   - `slice`: The slice of elements to convert to a map. It can contain elements of any type `T`.
//   - `keyFunc`: A function that takes an element of type `T` and returns a key of type `K`,
//     which is used as the key for each element in the resulting map.
//
// Returns:
//   - A map of type `map[K]T`, where each element in `slice` is inserted using the key
//     generated by `keyFunc`. If `keyFunc` generates the same key for multiple elements,
//     the last one will overwrite the previous entry in the map.
//
// Example:
//
//	// Converting a slice of strings to a map with string lengths as keys
//	words := []string{"apple", "banana", "cherry"}
//	wordMap := ToMap(words, func(word string) int { return len(word) })
//	// wordMap will be map[int]string{5: "apple", 6: "cherry"}
//	// Note: "banana" is overwritten by "cherry" as they have the same key 6
//
//	// Converting a slice of structs to a map using a struct field as the key
//	type Person struct {
//	    ID   int
//	    Name string
//	}
//	people := []Person{{ID: 1, Name: "Alice"}, {ID: 2, Name: "Bob"}}
//	personMap := ToMap(people, func(p Person) int { return p.ID })
//	// personMap will be map[int]Person{1: {ID: 1, Name: "Alice"}, 2: {ID: 2, Name: "Bob"}}
func ToMap[T any, K comparable](slice []T, keyFunc func(T) K) map[K]T {
	result := make(map[K]T)
	for _, item := range slice {
		result[keyFunc(item)] = item
	}
	return result
}

// ToSlice applies a mapping function to each element in the input slice
// and returns a new slice containing the results of the mapping.
//
// This function iterates over each element in the input slice `slice` and applies
// the provided `mapper` function to each element. The result of applying the mapping
// function to each element is stored in a new slice `mappedSlice`. This allows for
// transforming the elements of the input slice into a new slice of a different type.
//
// The function is generic, allowing it to work with slices of any type `T` as input,
// and the result can be a slice of any type `U`.
//
// Parameters:
//   - `slice`: The input slice containing elements of type `T` to be mapped.
//   - `mapper`: A function that takes an element of type `T` and returns a transformed
//     element of type `U`.
//
// Returns:
//   - A new slice of type `[]U` containing the mapped elements, with the same length
//     as the input slice, but with elements transformed according to the `mapper` function.
//
// Example:
//
//	// Mapping a slice of integers to their string representations
//	numbers := []int{1, 2, 3}
//	mappedStrings := ToSlice(numbers, func(n int) string {
//		return fmt.Sprintf("Number %d", n)
//	})
//	// mappedStrings will be []string{"Number 1", "Number 2", "Number 3"}
//
//	// Mapping a slice of strings to their lengths
//	words := []string{"apple", "banana", "cherry"}
//	mappedLengths := ToSlice(words, func(word string) int {
//		return len(word)
//	})
//	// mappedLengths will be []int{5, 6, 6}
//
//	// Mapping an empty slice returns an empty slice
//	empty := []int{}
//	mappedEmpty := ToSlice(empty, func(n int) string {
//		return fmt.Sprintf("Number %d", n)
//	})
//	// mappedEmpty will be []string{}
func ToSlice[T any, U any](slice []T, mapper func(T) U) []U {
	mappedSlice := make([]U, len(slice))
	for i, item := range slice {
		mappedSlice[i] = mapper(item)
	}
	return mappedSlice
}

// MergeMap combines multiple maps into a single map. If there are any key conflicts,
// the value from the last map will be used.
//
// This function accepts a variable number of maps of type `map[interface{}]V` and merges
// them into a single map. It iterates through each input map, adding all key-value pairs
// to the `mergedMap`. If a key already exists in `mergedMap`, the corresponding value
// from the current map will overwrite the existing value. The function returns the merged map.
//
// The function is generic, allowing it to work with maps where the key is of any type `K`
// and the value is of any type `V`. It uses `interface{}` as the key type, enabling it to
// handle a variety of key types, though this may require careful handling of the key types
// to ensure they are comparable if needed.
//
// Parameters:
//   - `maps`: A variadic parameter representing multiple maps to be merged. Each map has keys
//     of type `interface{}` and values of type `V`.
//
// Returns:
//   - A new map of type `map[interface{}]V` containing the merged key-value pairs. If there
//     are key conflicts, the last map's value will be used.
//
// Example:
//
//	// Merging two maps with integer keys and string values
//	map1 := map[interface{}]string{"a": "apple", "b": "banana"}
//	map2 := map[interface{}]string{"b": "blueberry", "c": "cherry"}
//	merged := MergeMap(map1, map2)
//	// merged will be map[interface{}]string{"a": "apple", "b": "blueberry", "c": "cherry"}
//
//	// Merging maps with different value types (e.g., int and string)
//	map3 := map[interface{}]int{"x": 10, "y": 20}
//	map4 := map[interface{}]string{"y": "yellow", "z": "zebra"}
//	mergedMixed := MergeMap(map3, map4)
//	// mergedMixed will be map[interface{}]string{"x": "10", "y": "yellow", "z": "zebra"}
//
//	// Merging an empty slice of maps returns an empty map
//	mergedEmpty := MergeMap()
//	// mergedEmpty will be an empty map
func MergeMap[K any, V any](maps ...map[any]V) map[any]V {
	merged := make(map[any]V)
	for _, m := range maps {
		for k, v := range m {
			merged[k] = v
		}
	}
	return merged
}

// DeepMergeMap merges two maps, deeply combining values from the source map into the target map.
//
// This function takes two maps: `target` and `source`, both with string keys and interface{} values. It recursively merges
// the values from the `source` map into the `target` map. If a key exists in both maps, the function checks if the values
// associated with the key are themselves maps. If so, it recursively merges the nested maps. Otherwise, it directly overwrites
// the target map's value with the value from the source map. This function allows for deep merging of nested maps.
//
// The function modifies the `target` map in place and does not return anything.
//
// Parameters:
//   - `target`: The map that will be updated with values from the `source`. It is modified in place.
//   - `source`: The map whose values will be merged into the `target`.
//
// Example:
//
//	// Merging two maps with nested maps
//	target := map[string]interface{}{
//		"fruit": map[string]interface{}{"apple": 5, "banana": 10},
//		"vegetable": map[string]interface{}{"carrot": 3},
//	}
//	source := map[string]interface{}{
//		"fruit": map[string]interface{}{"banana": 7, "orange": 2},
//		"vegetable": map[string]interface{}{"spinach": 5},
//		"grain": 100,
//	}
//	DeepMergeMap(target, source)
//	// target will now be:
//	// map[string]interface{}{
//	//		"fruit": map[string]interface{}{"apple": 5, "banana": 7, "orange": 2},
//	//		"vegetable": map[string]interface{}{"carrot": 3, "spinach": 5},
//	//		"grain": 100,
//	//	}
//
//	// If there is no conflict, the value from the source is added as is.
//	// If the source value is a nested map, the function will perform a deep merge.
func DeepMergeMap(target, source map[string]any) {
	for key, sourceValue := range source {
		if targetValue, exists := target[key]; exists {
			if sourceMap, sourceIsMap := sourceValue.(map[string]any); sourceIsMap {
				if targetMap, targetIsMap := targetValue.(map[string]any); targetIsMap {
					DeepMergeMap(targetMap, sourceMap)
				}
			} else {
				target[key] = sourceValue
			}
		} else {
			target[key] = sourceValue
		}
	}
}

// MergeMapStr merges multiple maps of type map[string]string into a single map.
//
// This function takes a variadic number of maps of type map[string]string and combines their key-value pairs into a
// single resulting map. If there are duplicate keys across the input maps, the value from the last map in the
// variadic list will overwrite the earlier ones.
//
// The function creates a new map to hold the merged results, iterating over each input map and adding its
// key-value pairs to the result map.
//
// Parameters:
//   - `maps`: A variadic parameter that takes one or more maps of type map[string]string to be merged.
//
// Returns:
//   - A new map of type map[string]string that contains all the key-value pairs from the input maps.
//     If a key appears in multiple maps, the value from the last map will be used.
//
// Example:
//
//	// Merging two maps
//	map1 := map[string]string{"a": "apple", "b": "banana"}
//	map2 := map[string]string{"b": "blueberry", "c": "cherry"}
//	merged := MergeMapStr(map1, map2)
//	// merged will be map[string]string{"a": "apple", "b": "blueberry", "c": "cherry"}
//
//	// Merging more than two maps
//	map3 := map[string]string{"d": "date"}
//	mergedAll := MergeMapStr(map1, map2, map3)
//	// mergedAll will be map[string]string{"a": "apple", "b": "blueberry", "c": "cherry", "d": "date"}
//
//	// If duplicate keys exist, the value from the last map wins
//	map4 := map[string]string{"a": "apricot"}
//	mergedWithDup := MergeMapStr(map1, map4)
//	// mergedWithDup will be map[string]string{"a": "apricot", "b": "banana"}
func MergeMapStr(maps ...map[string]string) map[string]string {
	result := make(map[string]string)
	for _, m := range maps {
		for k, v := range m {
			result[k] = v
		}
	}
	return result
}

// FilterMap filters the key-value pairs of a map based on a condition provided by the filter function.
//
// This function iterates over each key-value pair in the input map `m` and applies the provided
// `filter` function to the value. If the `filter` function returns `true` for a value, that key-value
// pair is added to the `filteredMap`. Otherwise, the pair is excluded. The function returns a new map
// containing only the key-value pairs that satisfy the condition specified in the `filter` function.
//
// The function is generic, allowing it to work with maps where the keys and values can be of any type `K`
// and `V`, respectively.
//
// Parameters:
//   - `m`: The input map to be filtered, with keys of type `any` and values of type `V`.
//   - `filter`: A function that takes a value of type `V` and returns a boolean. It determines
//     whether the corresponding key-value pair should be included in the result map.
//
// Returns:
//   - A new map of type `map[any]V`, containing only the key-value pairs for which the `filter`
//     function returned `true`.
//
// Example:
//
//	// Filtering a map of integers, keeping only values greater than 10
//	map1 := map[any]int{"a": 5, "b": 15, "c": 20}
//	filtered := FilterMap(map1, func(v int) bool {
//		return v > 10
//	})
//	// filtered will be map[any]int{"b": 15, "c": 20}
//
//	// Filtering a map of strings, keeping only values with length greater than 3
//	map2 := map[any]string{"a": "apple", "b": "banana", "c": "cat"}
//	filteredStrings := FilterMap(map2, func(v string) bool {
//		return len(v) > 3
//	})
//	// filteredStrings will be map[any]string{"a": "apple", "b": "banana"}
//
//	// Filtering an empty map returns an empty map
//	emptyMap := map[any]int{}
//	filteredEmpty := FilterMap(emptyMap, func(v int) bool {
//		return v > 10
//	})
//	// filteredEmpty will be an empty map
func FilterMap[K any, V any](m map[any]V, filter func(V) bool) map[any]V {
	filteredMap := make(map[any]V)
	for k, v := range m {
		if filter(v) {
			filteredMap[k] = v
		}
	}
	return filteredMap
}

// Values extracts and returns the values from a map as a slice.
//
// This function takes a map `m` with keys of type `any` and values of type `V`, and creates
// a new slice containing all the values from the map. The function iterates over the map and
// appends each value to the `values` slice. The resulting slice will have the same number of
// elements as the map has key-value pairs, and the order of values will correspond to the
// order in which they were iterated over (which is not guaranteed to be in any particular order).
//
// The function is generic, allowing it to work with maps of any key type `K` and value type `V`.
//
// Parameters:
//   - `m`: The input map from which to extract the values. The keys are of type `any`
//     and the values are of type `V`.
//
// Returns:
//   - A slice of type `[]V` containing all the values from the map `m`.
//
// Example:
//
//	// Extracting values from a map of strings to integers
//	map1 := map[any]int{"a": 1, "b": 2, "c": 3}
//	values := Values(map1)
//	// values will be []int{1, 2, 3}
//
//	// Extracting values from a map of strings to strings
//	map2 := map[any]string{"x": "apple", "y": "banana", "z": "cherry"}
//	valuesStrings := Values(map2)
//	// valuesStrings will be []string{"apple", "banana", "cherry"}
//
//	// Extracting values from an empty map returns an empty slice
//	emptyMap := map[any]int{}
//	emptyValues := Values(emptyMap)
//	// emptyValues will be []int{}
func Values[K any, V any](m map[any]V) []V {
	values := make([]V, len(m))
	i := 0
	for _, v := range m {
		values[i] = v
		i++
	}
	return values
}

// JoinMapKeys concatenates the keys of a map into a single string, with each key separated by a specified separator.
//
// This function takes a map `m` with string keys and any type of values `V`, and a `separator` string.
// It collects all the keys of the map into a slice, then joins them into a single string using the provided separator.
//
// This function is generic, allowing it to work with maps that have values of any type `V`.
//
// Parameters:
//   - `m`: A map with string keys and values of any type `V`. Only the keys are used for concatenation.
//   - `separator`: A string used to separate each key in the resulting string.
//
// Returns:
//   - A string containing all the keys in the map `m`, separated by the specified `separator`. If the map has no keys,
//     an empty string is returned.
//
// Example:
//
//	// Concatenating the keys of a map with a comma separator
//	m := map[string]int{"apple": 1, "banana": 2, "cherry": 3}
//	joinedKeys := JoinMapKeys(m, ", ")
//	// joinedKeys will be "apple, banana, cherry"
//
//	// Using a different separator
//	m = map[string]bool{"cat": true, "dog": true}
//	joinedKeys = JoinMapKeys(m, " | ")
//	// joinedKeys will be "cat | dog"
//
//	// With an empty map
//	emptyMap := map[string]int{}
//	joinedKeys = JoinMapKeys(emptyMap, ",")
//	// joinedKeys will be ""
func JoinMapKeys[V any](m map[string]V, separator string) string {
	joined_keys := []string{}
	for key := range m {
		joined_keys = append(joined_keys, key)
	}
	return strings.Join(joined_keys, separator)
}
